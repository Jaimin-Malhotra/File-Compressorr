<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman File Compressor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .file-drop-area {
            transition: all 0.2s ease-in-out;
        }
        .file-drop-area.dragover {
            background-color: #e0f2fe; /* light blue */
            border-color: #0284c7; /* sky blue */
        }
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl bg-white rounded-2xl shadow-lg p-6 md:p-8 space-y-6">
        <!-- Header Section -->
        <div class="text-center">
            <h1 class="text-3xl font-bold text-gray-800">Huffman File Compressor</h1>
            <p class="text-gray-500 mt-2">Upload any file to compress it using the lossless Huffman algorithm.</p>
        </div>

        <!-- File Upload Section -->
        <div id="file-drop-area" class="file-drop-area border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer">
            <input type="file" id="file-input" class="hidden">
            <div class="flex flex-col items-center">
                 <svg class="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                <p class="mt-4 text-lg text-gray-600">
                    <span class="font-semibold text-blue-600">Click to upload</span> or drag and drop
                </p>
                <p id="file-name" class="mt-2 text-sm text-gray-500">No file selected</p>
            </div>
        </div>

        <!-- Compression Controls Section -->
        <div class="space-y-4">
            <label for="compression-slider" class="block font-medium text-gray-700">Compression Level</label>
            <div class="flex items-center space-x-4">
                <input id="compression-slider" type="range" min="0" max="100" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" disabled>
                <span class="font-semibold text-gray-800">100%</span>
            </div>
            <div class="bg-blue-50 border border-blue-200 text-blue-800 text-sm rounded-lg p-3">
                <p><span class="font-bold">Note:</span> Huffman coding is a lossless algorithm that finds one optimal compression level. This slider is for demonstration purposes only.</p>
            </div>
        </div>
        
        <!-- Action Button -->
        <button id="compress-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed">
            Compress File
        </button>

        <!-- Results Section -->
        <div id="results-section" class="hidden space-y-4 pt-4 border-t">
            <h2 class="text-xl font-semibold text-gray-800 text-center">Compression Results</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                <div class="bg-gray-50 p-4 rounded-lg">
                    <p class="text-sm text-gray-500">Original Size</p>
                    <p id="original-size" class="text-lg font-bold text-gray-900">-</p>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg">
                    <p class="text-sm text-gray-500">Compressed Size</p>
                    <p id="compressed-size" class="text-lg font-bold text-green-600">-</p>
                </div>
                <div class="bg-gray-50 p-4 rounded-lg">
                    <p class="text-sm text-gray-500">Reduction</p>
                    <p id="reduction-ratio" class="text-lg font-bold text-blue-600">-</p>
                </div>
            </div>
            <div id="loader" class="hidden w-8 h-8 mx-auto border-4 border-gray-200 rounded-full loader"></div>
            <a id="download-link" class="hidden w-full text-center bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-200">
                Download Compressed File
            </a>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const fileDropArea = document.getElementById('file-drop-area');
        const fileInput = document.getElementById('file-input');
        const fileNameDisplay = document.getElementById('file-name');
        const compressBtn = document.getElementById('compress-btn');
        const resultsSection = document.getElementById('results-section');
        const originalSizeDisplay = document.getElementById('original-size');
        const compressedSizeDisplay = document.getElementById('compressed-size');
        const reductionRatioDisplay = document.getElementById('reduction-ratio');
        const downloadLink = document.getElementById('download-link');
        const loader = document.getElementById('loader');

        let selectedFile = null;

        // --- Event Listeners ---
        fileDropArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);

        // Drag and Drop Listeners
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, preventDefaults, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, () => fileDropArea.classList.add('dragover'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, () => fileDropArea.classList.remove('dragover'), false);
        });
        fileDropArea.addEventListener('drop', handleDrop, false);

        compressBtn.addEventListener('click', handleCompression);

        // --- Event Handlers ---
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                selectedFile = files[0];
                updateFileInfo();
            }
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                selectedFile = files[0];
                fileInput.files = files; // Sync with file input
                updateFileInfo();
            }
        }

        function updateFileInfo() {
            if (selectedFile) {
                fileNameDisplay.textContent = `${selectedFile.name} (${formatBytes(selectedFile.size)})`;
                compressBtn.disabled = false;
                resultsSection.classList.add('hidden');
                downloadLink.classList.add('hidden');
            } else {
                fileNameDisplay.textContent = 'No file selected';
                compressBtn.disabled = true;
            }
        }

        async function handleCompression() {
            if (!selectedFile) {
                alert("Please select a file first.");
                return;
            }

            // Reset UI for new compression
            setLoadingState(true);
            resultsSection.classList.remove('hidden');
            originalSizeDisplay.textContent = formatBytes(selectedFile.size);
            compressedSizeDisplay.textContent = '-';
            reductionRatioDisplay.textContent = '-';

            try {
                // We use a timeout to allow the UI to update before the heavy computation starts
                setTimeout(async () => {
                    const arrayBuffer = await selectedFile.arrayBuffer();
                    const data = new Uint8Array(arrayBuffer);

                    // --- Core Huffman Logic ---
                    const { compressedBlob, compressedSize } = huffmanCompress(data);

                    // Update UI with results
                    compressedSizeDisplay.textContent = formatBytes(compressedSize);
                    const reduction = 100 - (compressedSize / selectedFile.size) * 100;
                    reductionRatioDisplay.textContent = `${reduction.toFixed(2)}%`;

                    // Prepare download link
                    const compressedUrl = URL.createObjectURL(compressedBlob);
                    downloadLink.href = compressedUrl;
                    downloadLink.download = `${selectedFile.name}.huff`;
                    
                    setLoadingState(false);
                }, 50);

            } catch (error) {
                console.error("Compression failed:", error);
                alert("An error occurred during compression.");
                setLoadingState(false);
            }
        }
        
        function setLoadingState(isLoading) {
            if (isLoading) {
                compressBtn.disabled = true;
                compressBtn.textContent = 'Compressing...';
                loader.classList.remove('hidden');
                downloadLink.classList.add('hidden');
            } else {
                compressBtn.disabled = false;
                compressBtn.textContent = 'Compress File';
                loader.classList.add('hidden');
                downloadLink.classList.remove('hidden');
            }
        }

        // --- Huffman Coding Implementation ---

        /**
         * The main function to orchestrate the Huffman compression process.
         * @param {Uint8Array} data - The raw byte data of the file.
         * @returns {object} An object containing the compressed data as a Blob and its size.
         */
        function huffmanCompress(data) {
            // 1. Calculate frequency of each byte
            const frequencies = getFrequencies(data);

            // 2. Build the Huffman Tree
            const treeRoot = buildHuffmanTree(frequencies);

            // 3. Generate Huffman codes for each byte
            const codes = generateCodes(treeRoot);

            // 4. Encode the data using the generated codes
            const encodedBitString = encodeData(data, codes);
            
            // 5. Pack the data into a binary format for download
            const packedData = packData(encodedBitString, frequencies);

            // 6. Create a Blob from the packed data
            const compressedBlob = new Blob([packedData]);

            return { compressedBlob, compressedSize: compressedBlob.size };
        }

        /**
         * Calculates the frequency of each byte in the input data.
         * @param {Uint8Array} data - The input byte array.
         * @returns {Map<number, number>} A map of byte value to its frequency.
         */
        function getFrequencies(data) {
            const freqMap = new Map();
            for (const byte of data) {
                freqMap.set(byte, (freqMap.get(byte) || 0) + 1);
            }
            return freqMap;
        }

        // Node class for the Huffman Tree
        class HuffmanNode {
            constructor(byte, freq, left = null, right = null) {
                this.byte = byte; // The byte value (0-255)
                this.freq = freq; // The frequency of the byte
                this.left = left; // Left child node
                this.right = right; // Right child node
            }
        }

        /**
         * Builds the Huffman Tree from the frequency map.
         * @param {Map<number, number>} frequencies - The frequency map.
         * @returns {HuffmanNode} The root node of the Huffman Tree.
         */
        function buildHuffmanTree(frequencies) {
            // Create a priority queue (min-heap) of leaf nodes
            const priorityQueue = [];
            for (const [byte, freq] of frequencies.entries()) {
                priorityQueue.push(new HuffmanNode(byte, freq));
            }
            // Sort to simulate a priority queue (less efficient but simpler for this demo)
            priorityQueue.sort((a, b) => a.freq - b.freq);

            if (priorityQueue.length === 0) return null;
            if (priorityQueue.length === 1) {
                const leaf = priorityQueue[0];
                return new HuffmanNode(null, leaf.freq, leaf, null);
            }

            // Combine nodes until only one root node remains
            while (priorityQueue.length > 1) {
                const left = priorityQueue.shift();
                const right = priorityQueue.shift();
                const parent = new HuffmanNode(null, left.freq + right.freq, left, right);
                
                // Insert the new parent node back into the sorted queue
                let inserted = false;
                for (let i = 0; i < priorityQueue.length; i++) {
                    if (parent.freq < priorityQueue[i].freq) {
                        priorityQueue.splice(i, 0, parent);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) {
                    priorityQueue.push(parent);
                }
            }
            return priorityQueue[0];
        }

        /**
         * Generates the binary codes for each byte by traversing the Huffman Tree.
         * @param {HuffmanNode} treeRoot - The root of the Huffman Tree.
         * @returns {Map<number, string>} A map of byte value to its Huffman code string.
         */
        function generateCodes(treeRoot) {
            const codesMap = new Map();
            function traverse(node, currentCode) {
                if (!node) return;
                // If it's a leaf node, we've found a code for a byte
                if (node.byte !== null) {
                    codesMap.set(node.byte, currentCode || '0'); // Handle single-node tree
                    return;
                }
                // Traverse left ('0') and right ('1')
                traverse(node.left, currentCode + '0');
                traverse(node.right, currentCode + '1');
            }
            traverse(treeRoot, '');
            return codesMap;
        }

        /**
         * Encodes the original data into a string of bits using the Huffman codes.
         * @param {Uint8Array} data - The original file data.
         * @param {Map<number, string>} codes - The Huffman codes map.
         * @returns {string} The encoded data as a string of '0's and '1's.
         */
        function encodeData(data, codes) {
            let encodedString = '';
            for (const byte of data) {
                encodedString += codes.get(byte);
            }
            return encodedString;
        }

        /**
         * Packs the encoded bit string and frequency table into a final Uint8Array.
         * The format is: [JSON Header Length (4 bytes)] -> [JSON Header] -> [Padding Bits (1 byte)] -> [Compressed Data]
         * @param {string} encodedBitString - The string of '0's and '1's.
         * @param {Map<number, number>} frequencies - The frequency map for the header.
         * @returns {Uint8Array} The final compressed byte array.
         */
        function packData(encodedBitString, frequencies) {
            // 1. Create the header (frequency table)
            const freqArray = Array.from(frequencies.entries());
            const headerString = JSON.stringify(freqArray);
            const headerBytes = new TextEncoder().encode(headerString);
            
            // 2. Create header length prefix (32-bit integer)
            const headerLengthBytes = new Uint8Array(4);
            new DataView(headerLengthBytes.buffer).setUint32(0, headerBytes.length, false); // Big-endian

            // 3. Calculate padding
            const padding = (8 - (encodedBitString.length % 8)) % 8;
            const paddingByte = new Uint8Array([padding]);

            // 4. Convert bit string to actual bytes
            const dataLength = Math.ceil(encodedBitString.length / 8);
            const dataBytes = new Uint8Array(dataLength);
            for (let i = 0; i < dataLength; i++) {
                const byteString = encodedBitString.substring(i * 8, (i + 1) * 8);
                dataBytes[i] = parseInt(byteString.padEnd(8, '0'), 2);
            }

            // 5. Combine all parts into one array
            const packed = new Uint8Array(headerLengthBytes.length + headerBytes.length + paddingByte.length + dataBytes.length);
            packed.set(headerLengthBytes, 0);
            packed.set(headerBytes, 4);
            packed.set(paddingByte, 4 + headerBytes.length);
            packed.set(dataBytes, 4 + headerBytes.length + 1);

            return packed;
        }

        // --- Utility Functions ---
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // Initial state
        updateFileInfo();
    </script>
</body>
</html>
